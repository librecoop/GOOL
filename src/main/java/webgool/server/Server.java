package webgool.server;

import gool.GOOLCompiler;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;




/**
 * The Server class does contain the listeners used by Glassfish to react to network sockets.<br>
 * It provides the convenient annotated classes and methods that Glassfish needs to properly react.<br>
 * For example, ServerEndPoint does correspond to the class that will be used by all the connection requests on WWWglassfish/domaine/appli .<br>
 * Another example is the OnMessage annotation that does execute the associated method each time an input message is detected.<br> 
 * @author Charbel FOUREL
 * @version 0.1a
 * 
 */
@ServerEndpoint("/appli")
public class Server {

	private Map<String , String> tabResults = new HashMap<String, String>();
	private String userLang = "en";
	private String outputlang = "unknown";

	/**
	 * Executed method when a connection is established with a client.
	 * @param session - the unique Session created for the client.
	 */
	@OnOpen
	public void onOpen(Session session){
		System.out.println("INFOS: " + session.getId() + " has log in.");
	}

	/**
	 * Executed method when a message from a client is received.
	 * @param message - the message sent by the client.
	 * @param session - the unique session created for the client
	 */
	@OnMessage
	public void onMessage(String message, Session session){
		ByteArrayOutputStream consoleToString = new ByteArrayOutputStream();
		PrintStream flux = new PrintStream(consoleToString);
		System.setErr(flux);

		// Delimiter definition for parsing
		String delimiter = "[§]";
		
		// Table generated by the parsing
		String[] elements = message.split(delimiter);
		// If execution is asking
		if (message.startsWith("@§exec§")){
			String messageOut = new String("t@");
			String messageErr = new String("t1");
			
			if (tabResults.isEmpty()){
				messageErr += "No input files has been found";
			}
			else{
				// message is @&exec&mainclassname
				String mainClass = elements[2];
				try{
					List<String> stdout = GOOLCompiler.launchHTMLExecution(outputlang, tabResults, mainClass);
//					for (String st : stdout){
//						System.out.println("DEBUG : " + st);
//					}
					messageOut += "§" + stdout.get(0);
					messageErr += "§" + stdout.get(1);
					session.getBasicRemote().sendText(messageOut);
				}
				catch (Exception e) {
					System.err.println(e);
					messageErr += "§" + consoleToString.toString();
				}
			}
			try {				
				session.getBasicRemote().sendText(messageErr);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		// Else it is a translation
		else{			
				
			/* An input message will, for example, have the following structure : @§fr§Java§C++§content
			 * The parser will then create a table with:
			 * elements [0] == @
			 * elements [1] == fr
			 * elements [2] == Java
			 * elements [3] == C++
			 * elements [4] == the content to process
			 * 
			 * elements [0] is the type of the message : @ for the processing, 1 for the errors/
			 * elements [1] is the user language.
			 * elements [2] is the input computer language chosen by the user.
			 * elements [3] is the output computer language chosen by the user.
			 * elements [4] is the content of the code the user wants to process.
			 */

			if (elements[0].equals("@")) {

				String messageOut = new String("@");
				String messageErr = new String("");
				tabResults = new HashMap<String, String>();

				/*
				 * An output message will, for example, have the following structure : @§contenu
				 * The parser will then give to the client the following table:
				 * elements [0] == @
				 * elements [1] == the processed content
				 * 
				 * elements [0] is the type of the message : @ for the translated content, 1 for the errors.
				 * elements [1] is the translated content.
				 */
				try {
					// translator call
					outputlang = elements[3];
					tabResults = GOOLCompiler.launchHTMLTranslation(elements[2], elements[3],
							elements[4]);
					//				for(String str: tabResults.keySet()){
					//					System.out.println("########### " + str + " ###########");
					//					System.out.println(tabResults.get(str));
					//				}
					// output message construction
					for (Map.Entry<String, String> entry : tabResults.entrySet()) {
						messageOut += "§" + entry.getKey() + "§" + entry.getValue();
					}
					session.getBasicRemote().sendText(messageOut); 
					if(elements [1].equals("fr")){
						messageErr = "Traitement correctement exécuté par le serveur";
					}else{
						messageErr = "Server treatment properly executed";
					}
				} catch(Exception e) {
					System.err.println(e);
					messageErr = consoleToString.toString();
				}
				try {
					session.getBasicRemote().sendText("1§" + messageErr);
				} catch (IOException e) {
					e.printStackTrace();
				}				
			}
		}
		// references set to null for the garbage collector
		consoleToString = null;
		flux = null;
	}

	/**
	 * Executed method when a socket is closed by a client.
	 * @param session - the unique session created for the client
	 */
	@OnClose
	public void onClose(Session session){
		System.out.println("INFOS: " + session.getId() + " has log out.");
	}
}



